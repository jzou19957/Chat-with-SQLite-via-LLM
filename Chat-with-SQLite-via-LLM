import os
import glob
import sqlite3
import logging
import subprocess
import sys
import pandas as pd
import re
import json
import importlib
import base64
from typing import Dict, List, Any, Tuple
from datetime import datetime
import google.generativeai as generativeai
import matplotlib.pyplot as plt

# Configure logging
logging.basicConfig(level=logging.INFO, format='%(asctime)s - %(asctime)s - %(levelname)s - %(message)s',
                    handlers=[logging.FileHandler("data_analysis.log"), logging.StreamHandler()])
logger = logging.getLogger(__name__)

# Configure Google Gemini API
def configure_api():
    api_key = input("Enter your Google Gemini API key: ")
    generativeai.configure(api_key=api_key)
    return generativeai.GenerativeModel('gemini-1.5-flash')

model = configure_api()

def print_and_log(message: str):
    """Utility function to print and log messages."""
    print(message)
    logger.info(message)

def call_generative_api(prompt: str) -> str:
    """Function to call the Google Gemini API with a prompt."""
    print_and_log("Sending request to Generative API...")
    try:
        response = model.generate_content(prompt)
        print_and_log("Received response from Generative API.")
        return response.text
    except Exception as exception:
        print_and_log(f"Error calling Generative API: {str(exception)}")
        return None

def extract_code_blocks(llm_response: str) -> List[str]:
    """Extracts multiple code blocks from the LLM response."""
    code_blocks = re.findall(r"#begin(.*?)#end", llm_response, re.DOTALL)
    if not code_blocks:
        raise ValueError("No valid code blocks found in the LLM response.")
    return [block.strip() for block in code_blocks]

def clean_python_code(code: str) -> str:
    """Cleans the generated Python code to ensure it is valid."""
    # Remove any markdown-like syntax
    code = re.sub(r'-\s*\*\*.*?\*\*\s*:', '', code)
    return code

def install_package(package_name: str):
    """Installs a package using pip."""
    try:
        subprocess.check_call([sys.executable, "-m", "pip", "install", package_name])
        print_and_log(f"Successfully installed {package_name}.")
    except subprocess.CalledProcessError as e:
        print_and_log(f"Failed to install {package_name}: {e}")
        return False
    return True

def try_install_alternative(libraries: List[str]) -> str:
    """Tries to install alternative libraries until one succeeds."""
    for library in libraries:
        if install_package(library):
            return library
    raise RuntimeError(f"All library installation attempts failed: {', '.join(libraries)}")

def reflect_and_retry(code: str, error_message: str) -> str:
    """Generates a reflection prompt based on the error and previous code, and tries again."""
    reflection_prompt = f"""
    The following Python code was executed, but an error occurred:
    ```
    {code}
    ```
    Error Message: "{error_message}"

    Please analyze this situation:
    1. What is the error message and its cause?
    2. Is it an easy fix? If so, provide the corrected code.
    3. If it is not an easy fix, suggest a different library or method that can deliver an equally good result.
    4. Generate new Python code accordingly. Use commonly available libraries and methods suitable for the task.
    Respond with the revised Python code inside #begin and #end markers.
    """
    new_code_response = call_generative_api(reflection_prompt)
    return new_code_response

def execute_python_code(code_blocks: List[str], output_folder: str) -> str:
    """Executes the provided Python code blocks sequentially and returns the output."""
    output_str = ""
    for idx, code in enumerate(code_blocks):
        cleaned_code = clean_python_code(code)
        code_filename = f"analysis_code_{idx}.py"
        
        with open(code_filename, "w") as f:
            f.write(cleaned_code)

        try:
            # Check and install missing packages with alternatives
            required_packages = re.findall(r"import (\w+)|from (\w+) import", cleaned_code)
            for package in required_packages:
                package_name = package[0] or package[1]
                try:
                    importlib.import_module(package_name)
                except ImportError:
                    # If package import fails, try alternatives
                    alternatives = {
                        "matplotlib": ["plotly", "bokeh"],
                        "seaborn": ["plotly", "bokeh"],
                        # Add other libraries and their alternatives here
                    }
                    package_to_install = try_install_alternative(alternatives.get(package_name, [package_name]))
                    cleaned_code = cleaned_code.replace(package_name, package_to_install)

            # Execute the code block
            result = subprocess.run([sys.executable, code_filename], capture_output=True, text=True, check=True)
            output_path = os.path.join(output_folder, f"output_{idx}.txt")
            with open(output_path, "w") as output_file:
                output_file.write(result.stdout)
            print_and_log(f"Python code block {idx + 1} executed successfully. Output saved to {output_path}")
            output_str += result.stdout + "\n"
        except subprocess.CalledProcessError as e:
            error_message = e.stderr
            print_and_log(f"Error executing Python code block {idx + 1}: {error_message}")
            try:
                # Reflect on the error and retry
                new_code_response = reflect_and_retry(cleaned_code, error_message)
                new_code_blocks = extract_code_blocks(new_code_response)
                return execute_python_code(new_code_blocks, output_folder)
            except Exception as reflection_exception:
                print_and_log(f"Reflection and retry failed: {reflection_exception}")
                raise RuntimeError(f"Error after reflection and retry: {reflection_exception}")
        finally:
            os.remove(code_filename)  # Clean up generated script file
    return output_str.strip()

def encode_image_to_base64(image_path: str) -> str:
    """Encodes an image to a Base64 string."""
    with open(image_path, "rb") as image_file:
        return base64.b64encode(image_file.read()).decode('utf-8')

class DataAnalysisTool:
    def __init__(self, db_file: str, user_query: str):
        self.db_file = db_file
        self.user_query = user_query
        self.db_structure = self.get_db_structure()
        self.sample_data = self.get_sample_data()
        self.output_folder = self.create_output_folder()
        os.makedirs(self.output_folder, exist_ok=True)

    def create_output_folder(self) -> str:
        """Creates a unique output folder based on the database file name and the user query."""
        base_name = os.path.splitext(self.db_file)[0]
        folder_name = f"{base_name}_Q_{self.user_query[:30].replace(' ', '_').replace(':', '')}"
        os.makedirs(folder_name, exist_ok=True)
        return folder_name

    def get_db_structure(self) -> Dict[str, List[str]]:
        """Retrieves the structure of the SQLite database."""
        conn = sqlite3.connect(self.db_file)
        cursor = conn.cursor()
        cursor.execute("SELECT name FROM sqlite_master WHERE type='table';")
        tables = cursor.fetchall()
        structure = {}
        for table in tables:
            table_name = table[0]
            cursor.execute(f"PRAGMA table_info({table_name})")
            columns = cursor.fetchall()
            structure[table_name] = [col[1] for col in columns]
        conn.close()
        return structure

    def get_sample_data(self, sample_size: int = 5) -> Dict[str, List[Dict[str, Any]]]:
        """Retrieves sample data from each table in the database."""
        conn = sqlite3.connect(self.db_file)
        cursor = conn.cursor()
        sample_data = {}
        for table_name, columns in self.db_structure.items():
            cursor.execute(f"SELECT * FROM {table_name} LIMIT {sample_size}")
            rows = cursor.fetchall()
            sample_data[table_name] = [dict(zip(columns, row)) for row in rows]
        conn.close()
        return sample_data

    def assess_query_complexity(self, user_query: str) -> Tuple[str, str]:
        """Assesses the complexity of the user's query."""
        prompt = f"""
        Analyze the following user query and database structure to determine the most appropriate method to answer it:
        User Query: "{user_query}"
        Database Structure: {json.dumps(self.db_structure, indent=2)}
        Sample Data: {json.dumps(self.sample_data, indent=2)}
        Determine which of the following methods is most appropriate:
        1. "SIMPLE_SQLITE" - If the query can be answered with a straightforward SQLite query.
        2. "COMPLEX_SQLITE" - If the query requires a more complex SQLite query (e.g., multiple joins, subqueries).
        3. "PYTHON_PANDAS" - If the query requires data manipulation or analysis that's better suited for Python and pandas.
        4. "PYTHON_VISUALIZATION" - If the query requires creating charts or visualizations.
        Please respond with the code inside #begin and #end markers.
        """
        response = call_generative_api(prompt)
        if not response:
            return "PYTHON_PANDAS", "Failed to assess query complexity. Defaulting to Python with pandas."
        decision, explanation = response.split("\n", 1)
        return decision.strip(), explanation.strip()

    def generate_sqlite_query(self, user_query: str, complexity: str) -> str:
        """Generates a SQLite query based on the user's query and complexity."""
        initial_query_prompt = f"""
        You are a top-tier AI data scientist with specialized expertise in handling SQLite .db files. You are adept at understanding complex database structures, crafting efficient SQL queries, and leveraging advanced Python libraries tailored for data analysis and visualization. Your role is to deliver precise and optimized solutions for data extraction, manipulation, and visualization while maintaining the integrity and accuracy of the database. Always prioritize using the most effective tools and methods, provide clear, well-documented code, and ensure every analysis is thorough, accurate, and actionable.

        Generate a SQLite query to precisely answer this question: '{user_query}'
        Query Complexity: {complexity}
        Database structure: {json.dumps(self.db_structure, indent=2)}
        Sample Data: {json.dumps(self.sample_data, indent=2)}
        """
        return call_generative_api(initial_query_prompt)

    def generate_python_code(self, user_query: str, complexity: str) -> str:
        """Generates Python code to analyze the data."""
        initial_code_prompt = f"""
        You are a Python specialist with deep expertise in data science tasks, including data manipulation, analysis, and visualization using libraries like NumPy, Pandas, Matplotlib, and Seaborn. You excel at writing clear, efficient, and optimized code. You have full control to install any necessary packages, modify plans, and adjust code to ensure optimal performance and accuracy. Whenever providing code examples, ensure they are enclosed within #begin and #end markers. Focus on delivering precise, high-quality solutions that are easy to understand and maintain. Prioritize data accuracy, visualization clarity, and computational efficiency in all tasks.
        
        All visualizations must adhere to academic and scientific standards, including appropriate titles, legends, labels, and sources. Provide a descriptive summary of the visualization's content and purpose before running the visualization code.
        
        Generate Python code to precisely answer this question: '{user_query}'
        Analysis Type: {complexity}
        Database structure: {json.dumps(self.db_structure, indent=2)}
        Sample Data: {json.dumps(self.sample_data, indent=2)}
        """
        return call_generative_api(initial_code_prompt)

    def execute_sqlite_query(self, query: str) -> pd.DataFrame:
        """Executes a SQLite query and returns the result as a DataFrame."""
        conn = sqlite3.connect(self.db_file)
        try:
            result = pd.read_sql_query(query, conn)
            output_path = os.path.join(self.output_folder, "sqlite_query_result.csv")
            result.to_csv(output_path, index=False)
            print_and_log(f"Query result saved to {output_path}")
            return result
        except Exception as e:
            logger.error(f"Error executing SQLite query: {str(e)}")
            raise
        finally:
            conn.close()

    def analyze(self, user_query: str) -> str:
        """Analyzes the database based on the user's query."""
        complexity, explanation = self.assess_query_complexity(user_query)
        print_and_log(f"Query complexity assessment: {complexity}")
        print_and_log(f"Explanation: {explanation}")

        analysis_metadata = {
            "user_query": user_query,
            "db_file": self.db_file,
            "date_time": datetime.now().strftime("%Y-%m-%d %H:%M:%S"),
            "result_description": "",
            "visualization_description": "",
            "visualization_base64": ""
        }

        max_attempts = 15
        for attempt in range(max_attempts):
            try:
                if complexity in ("SIMPLE_SQLITE", "COMPLEX_SQLITE"):
                    try:
                        query = self.generate_sqlite_query(user_query, complexity)
                        result = self.execute_sqlite_query(query)
                        result_str = result.to_string()
                        analysis_metadata["result_description"] = "SQL Query executed successfully. Results saved in CSV format."
                    except Exception:
                        print_and_log("SQLite execution failed, falling back to Python.")
                        complexity = "PYTHON_PANDAS"  # Fallback to Python
                        code = self.generate_python_code(user_query, complexity)
                        result_str = execute_python_code(extract_code_blocks(code), self.output_folder)
                        analysis_metadata["result_description"] = "Python analysis executed successfully."
                else:
                    code = self.generate_python_code(user_query, complexity)
                    result_str = execute_python_code(extract_code_blocks(code), self.output_folder)
                    analysis_metadata["result_description"] = "Python visualization executed successfully."

                if complexity == "PYTHON_VISUALIZATION":
                    # Save visualization description for analysis
                    visualization_desc = self.describe_visualization(self.output_folder)
                    analysis_metadata["visualization_description"] = visualization_desc
                    # Encode the visualization to Base64
                    for file in os.listdir(self.output_folder):
                        if file.endswith(('.png', '.jpg', '.jpeg', '.svg')):
                            image_path = os.path.join(self.output_folder, file)
                            analysis_metadata["visualization_base64"] = encode_image_to_base64(image_path)

                interpretation = self.interpret_result(user_query, result_str, complexity)
                analysis_metadata["llm_answer"] = interpretation

                output_file_path = os.path.join(self.output_folder, "analysis_results.json")
                with open(output_file_path, "w") as output_file:
                    json.dump(analysis_metadata, output_file, indent=2)
                print_and_log(f"Analysis results saved to {output_file_path}")
                return interpretation

            except Exception as e:
                logger.error(f"Attempt {attempt + 1} failed: {str(e)}")
                if attempt == max_attempts - 1:
                    print_and_log("Attempting to generate alternative analysis due to failure.")
                    alternative_code = self.generate_alternative_analysis(user_query)
                    alternative_result_str = execute_python_code(extract_code_blocks(alternative_code), self.output_folder)
                    interpretation = self.interpret_result(user_query, alternative_result_str, "ALTERNATIVE_ANALYSIS")
                    analysis_metadata["llm_answer"] = interpretation
                    output_file_path = os.path.join(self.output_folder, "alternative_analysis_results.json")
                    with open(output_file_path, "w") as output_file:
                        json.dump(analysis_metadata, output_file, indent=2)
                    print_and_log(f"Alternative analysis results saved to {output_file_path}")
                    return interpretation

    def interpret_result(self, user_query: str, result: str, complexity: str) -> str:
        """Interprets the result of the analysis."""
        prompt = f"""
        The user asked: "{user_query}"
        The analysis method used was: {complexity}
        The analysis produced this result:
        {result}
        Please provide a comprehensive response to the user's question based on this result. Structure the response as follows:
        1. **Direct Answer**: Provide a concise answer to the user's question.
        2. **Detailed Calculation and Process**: Explain the steps, calculations, and methods used to arrive at the answer.
        3. **Limitations and Context**: Discuss any limitations in the dataset, the context of the query, and potential caveats or considerations in the answer provided.
        """
        return call_generative_api(prompt)

    def describe_visualization(self, output_folder: str) -> str:
        """Generates a description of the visualization."""
        visualization_files = [f for f in os.listdir(output_folder) if f.endswith(('.png', '.jpg', '.jpeg', '.svg'))]
        if not visualization_files:
            return "No visualization generated."
        
        description = f"Generated visualizations: {', '.join(visualization_files)}."
        description += " These visualizations represent the data analysis and insights as requested by the user query."
        return description

    def generate_alternative_analysis(self, user_query: str) -> str:
        """Generates alternative analysis or visualization based on the user's query intent."""
        prompt = f"""
        Generate an alternative analysis or visualization based on the user's query intent: '{user_query}'
        Database structure: {json.dumps(self.db_structure, indent=2)}
        Sample Data: {json.dumps(self.sample_data, indent=2)}
        Guidelines:
        1. The .db file is in the current working directory. Use glob to find it.
        2. Use SQLite to query the database and pandas for data manipulation.
        3. If the analysis type is PYTHON_VISUALIZATION, create visualizations using matplotlib, seaborn, or similar libraries.
        4. Handle potential errors such as missing data or unexpected data types.
        5. Optimize for performance by only reading necessary data from the database.
        6. For calculations like averages, exclude null values and potentially invalid values (e.g., zero for age).
        7. Provide counts of total records, valid records, and records excluded due to null or invalid values.
        8. If the question is ambiguous, provide multiple analyses to address different interpretations.
        9. Include comments explaining any assumptions or decisions made in the analysis.
        10. Save all generated visualizations and data outputs to the '{self.output_folder}' directory.
        11. Ensure the visualization is meticulous with only the right contents and is friendly to the eyes, and academic publication ready.
        12. Pay attention to the font size, color, placement of texts, font size, and ensure the font can display multilingual languages if applied.
        13. Ensure maximum aesthetic, modernity, professionalism, and top-notched academic journal publication-ready quality.
        Please respond with the code inside #begin and #end markers.
        """
        return call_generative_api(prompt)

def main():
    try:
        # Update pip to the latest version
        subprocess.check_call([sys.executable, "-m", "pip", "install", "--upgrade", "pip"])
        print_and_log("Updated pip to the latest version.")

        # List available .db files
        db_files = glob.glob("*.db")
        if not db_files:
            raise FileNotFoundError("No .db files found in the current directory.")
        
        # Display available .db files and prompt user to select one
        print("Available .db files:")
        for idx, file in enumerate(db_files):
            print(f"{idx + 1}. {file}")
        choice = int(input("Select a .db file by number: ")) - 1
        db_file = db_files[choice]

        # Prompt user for query or context
        user_query = input("Enter the query or context for analysis: ")

        # Initialize DataAnalysisTool with user inputs
        data_tool = DataAnalysisTool(db_file, user_query)
        print(f"Database file: {data_tool.db_file}")
        print(f"Database structure:\n{json.dumps(data_tool.db_structure, indent=2)}")
        
        # Analyzing the user-provided query
        result = data_tool.analyze(user_query)
        print("\nAnalysis Result:")
        print(result)
        print("\n" + "="*50)
    except Exception as e:
        logger.error(f"An error occurred: {str(e)}")
        print(f"An error occurred: {str(e)}")

if __name__ == "__main__":
    main()
